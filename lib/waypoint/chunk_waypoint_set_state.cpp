/******************************************************************************
BigWorld Technology 
Copyright BigWorld Pty, Ltd.
All Rights Reserved. Commercial in confidence.

WARNING: This computer program is protected by copyright law and international
treaties. Unauthorized use, reproduction or distribution of this program, or
any portion of this program, may result in the imposition of civil and
criminal penalties as provided by law.
******************************************************************************/

#include "pch.hpp"

#include "chunk_waypoint_set_state.hpp"
#include "navigator.hpp"
#include "navloc.hpp"

#include <cfloat>
#include <sstream>

/**
 *	Constructor
 */
ChunkWPSetState::ChunkWPSetState() :
	pSet_(),
	blockNonPermissive_( false ),
	distanceFromParent_( 0.f ),
	passedActivatedPortal_( false ),
	passedShellBoundary_( false ),
	position_()
{
}

/**
 *	Constructor
 */
ChunkWPSetState::ChunkWPSetState( ChunkWaypointSetPtr pSet ) :
	pSet_( pSet ),
	blockNonPermissive_( false ),
	distanceFromParent_( 0.f ),
	passedActivatedPortal_( false ),
	passedShellBoundary_( false ),
	position_( pSet->chunk()->centre() )
{
}

/**
 *	Constructor
 */
ChunkWPSetState::ChunkWPSetState( const NavLoc & loc ) :
	pSet_( loc.pSet() ),
	blockNonPermissive_( false ),
	distanceFromParent_( 0.f ),
	passedActivatedPortal_( false ),
	passedShellBoundary_( false ),
	position_( loc.point() )
{
}


std::string ChunkWPSetState::desc() const
{
	std::stringstream ss;
	ss << '(' << position_.x << ", " <<
		position_.y << ", " <<
		position_.z << ") at " <<
		pSet_->chunk()->identifier();
	return ss.str();
}




/**
 *	This method gets the given adjacency, if it can be traversed.
 */
bool ChunkWPSetState::getAdjacency( ChunkWaypointConns::const_iterator iter,
		ChunkWPSetState & neigh,
		const ChunkWPSetState & goal ) const
{
	ChunkWaypointSetPtr pDestWaypointSet = iter->first;
	ChunkBoundary::Portal * pPortal = iter->second;

	Chunk * pFromChunk = pSet_->chunk();
	Chunk * pToChunk = pPortal->pChunk;

	/*
	DEBUG_MSG( "ChunkWPSetState::getAdjacency: "
		"considering connection from chunk %s to chunk %s\n",
		pFromChunk->identifier().c_str(),
		pToChunk->identifier().c_str() );
	*/


	// if blocking non permissive, and this non-permissive, then don't
	// consider.
	if (pPortal != NULL && !pPortal->permissive)
	{
		if (blockNonPermissive_)
		{
			return false;
		}
	}

	// Adjacent state inherits our value for blockNonPermissive_.
	neigh.blockNonPermissive_ = blockNonPermissive_;

	// find portal corresponding portal in cwc the other way.
	ChunkBoundary::Portal * pBackPortal = NULL;
	Chunk::piterator iPortal = pToChunk->pbegin();
	for (; iPortal != pToChunk->pend(); iPortal++)
	{
		if (iPortal->pChunk == pFromChunk)
		{
			ChunkBoundary::Portal & portal = *iPortal;
			pBackPortal = &portal;
			break;
		}
	}

	if (pBackPortal == NULL)
	{
		// TODO: Fix and change to error.
		WARNING_MSG( "ChunkWPSetState::getAdjacency: "
			"Encountered one way portal connection, "
			"assuming non passable.\n" );
		return false;
	}

	// now check if portal activated or not.
	neigh.passedShellBoundary(
		pFromChunk != pToChunk &&
		( !pFromChunk->isOutsideChunk() ||
			!pToChunk->isOutsideChunk() ) );

	if (neigh.passedShellBoundary())
	{
		neigh.passedActivatedPortal(
			pPortal->hasChunkItem() || pBackPortal->hasChunkItem() );
	}
	else
	{
		neigh.passedActivatedPortal( false );
	}

	neigh.pSet_ = pDestWaypointSet;

	if (!neigh.pSet_->chunk())
	{
		// TODO: Fix this properly. Nav system needs to be able to better deal
		// with chunks going away.
		WARNING_MSG( "ChunkWPSetState::getAdjacency: "
			"Chunk associated with neighbouring waypoint set "
			"no longer exists.\n" );
		return false;
	}

	// TODO: Should check that it's actually physically possible to go from the
	// portal that we came in on to the portal for this connection. This
	// information could be cached, or even generated by NavGen and stored in
	// the chunk waypoint set data.

	ChunkPtr pNextChunk = neigh.pSet_->chunk();
	const BoundingBox & bb = pNextChunk->localBB();
	Vector3 start = pNextChunk->transformInverse().applyPoint( position_ );
	Vector3 end = pNextChunk->transformInverse().applyPoint( goal.position_ );

	if (bb.clip( start, end ))
	{
		neigh.position_ = pNextChunk->transform().applyPoint( start );
	}
	else
	{
		Vector2 dir( end.x - start.x, end.z - start.z );

		Vector2 min( bb.maxBounds().x, bb.maxBounds().z );

		float minDistSquared = FLT_MAX;

		for (int i = 0; i < 4; ++i)
		{
			Vector2 p;
			p.x = ( i & 1 ) ? bb.minBounds().x : bb.maxBounds().x;
			p.y = ( i & 2 ) ? bb.minBounds().z : bb.maxBounds().z;

			Vector2 minVec( p.x - start.x, p.y - start.z );
			float distSquared = minVec.crossProduct( dir );
			distSquared = distSquared * distSquared;

			if (distSquared < minDistSquared)
			{
				min = p;
				minDistSquared = distSquared;
			}
		}
		neigh.position_ = pNextChunk->transform().applyPoint( 
			Vector3( min.x, start.y, min.y ) );
	}

	neigh.distanceFromParent_ = this->distanceToGoal( neigh );
	return true;
}

// chunk_waypoint_set_state.cpp
