/******************************************************************************
BigWorld Technology 
Copyright BigWorld Pty, Ltd.
All Rights Reserved. Commercial in confidence.

WARNING: This computer program is protected by copyright law and international
treaties. Unauthorized use, reproduction or distribution of this program, or
any portion of this program, may result in the imposition of civil and
criminal penalties as provided by law.
******************************************************************************/

#include "client_app.hpp"

#include "bots_config.hpp"
#include "main_app.hpp"
#include "movement_controller.hpp"
#include "py_entities.hpp"
#include "space_data_manager.hpp"

DECLARE_DEBUG_COMPONENT2( "Bots", 0 )

PY_TYPEOBJECT( ClientApp )

PY_BEGIN_METHODS( ClientApp )
	/*~ function ClientApp logOn
	*  @components{ bots }
	*  This function initiates the log on process for the simulated client 
	*  to connect to a BigWorld server.
	*/
	PY_METHOD( logOn )
	/*~ function ClientApp logOff
	*  @components{ bots }
	*  This function gracefully disconnects the simulated client from the 
	*  BigWorld server it is connected with. If the client is offline, this
	*  function has no effect.
	*/
	PY_METHOD( logOff )
	/*~ function ClientApp dropConnection
	*  @components{ bots }
	*  This function immediately drops the connection between the simulated 
	*  client and the BigWorld server. Use this function to simulate a sudden 
	*  network disconnection. If the client is offline, this function has no 
	*  effect.
	*/
	PY_METHOD( dropConnection )
	/*~ function ClientApp setConnectionLossRatio
	*  @components{ bots }
	*  This function sets packet lost ratio for the connection between the 
	*  simulated client and the BigWorld server. The input ratio must be in the
	*  range of [0.0,1.0]. 0.0 means no packet loss, whereas 1.0 mean 100 
	*  percent packet loss. Use this function to simulate an unstable network 
	*  connection with certain packet loss. If the client is offline, this 
	*  function has no effect.
	*
	*  @param	lostRatio		(float)		Packet loss ratio.
	*/

	PY_METHOD( setConnectionLossRatio )
	/*~ function ClientApp setConnectionLatency
	*  @components{ bots }
	*  This function sets packet latency for the connection between the 
	*  simulated client and the BigWorld server. The input values sets the
	*  latency range in milliseconds. Use this function to simulate an unstable
	*  network connection with variable data latency. If the client is offline, 
	*  this function has no effect.
	*
	*  @param	minLatency		(float)		Minimum latency between packets.
	*  @param	maxLatency		(float)		Maximum latency between packets.
	*/
	PY_METHOD( setConnectionLatency )
	/*~ function ClientApp setMovementController
	*  @components{ bots }
	*  This function sets the movement controller for the simulated client.
	*  The client use the patrol path generated by the movement controller to
	*  navigated around game world in order to simulate actual player movement.
	*  Upon failure, the previous movement controller will be reinstated.
	*
	*  BW provides only few elementary movement controllers with simple patrol
	*  paths. We recommend you use default movement controller. It reads in 
	*  custom designed patrol paths which you should create specifically for
	*  your game world environment. For details of how to custom desige patrol 
	*  path, check the server operation guide section 8.4.
	*
	*  @param	movementController	(string)Name of the movement controller.
	*										Note: The movement controller must
	*										have been compiled and visible to
	*										the Bots app.
	*
	*  @return				(boolean)	True if successful, otherwise, False.
	*/
	PY_METHOD( setMovementController )
	/*~ function ClientApp moveTo
	*  @components{ bots }
	*  This function sets a destination point for the player entity controlled 
	*  by the simulated client.
	*
	*  @param	destination		(Vector3)	Destination for the player entity 
	*										to move to.
	*/
	PY_METHOD( moveTo )
	/*~ function ClientApp faceTowards
	*  @components{ bots }
	*  This function sets a direction that the player entity controlled 
	*  by the simulated client should face
	*
	*  @param	direction		(Vector3)	Direction for the player entity
	*										to face.
	*/
	PY_METHOD( faceTowards )
	/*~ function ClientApp snapTo
	*  @components{ bots }
	*  This function sets(immediately) the position of the player entity 
	*  controlled by the simulated client.
	*
	*  @param	position		(Vector3)	New position for the player entity.
	*/
	PY_METHOD( snapTo )
	/*~ function ClientApp stop
	*  @components{ bots }
	*  This function stops the movement of the player entity controlled 
	*  by the simulated client.
	*
	*/
	PY_METHOD( stop )
	/*~ function ClientApp addTimer
	*  @components{ bots }
	*  This function adds a timer to the simulated client. The callback function
	*  included in the input parameters will be invoked during the next tick 
	*  after specified number of seconds has lapsed.
	*
	*  @param	interval	(float)		time interval for triggering the timer.
	*  @param	callback	(PyObject)	Callback function.
	*  @param	repeat		(boolean)	Should the timer be triggered repeatly.
	*
	*  @return	id		(integer)		The ID for the newly added timer.
	*/
	PY_METHOD( addTimer )
	/*~ function ClientApp delTimer
	*  @components{ bots }
	*  This function deletes an existing timer on the simulated client.
	*
	*  @param	id		(integer)	Timer ID.
	*/
	PY_METHOD( delTimer )
PY_END_METHODS()

PY_BEGIN_ATTRIBUTES( ClientApp )
	/*~ attribute ClientApp id
	*  @components{ bots }
	*  The player entity id of the simulated client
	*  @type Read-only integer
	*/
	PY_ATTRIBUTE( id )
	/*~ attribute ClientApp spaceID
	*  @components{ bots }
	*  The ID of the space that the player entity is currently in.
	*  @type Read-only integer
	*/
	PY_ATTRIBUTE( spaceID )
	/*~ attribute ClientApp loginName
	*  @components{ bots }
	*  The login name used by the simulated client.
	*  @type Read-only string
	*/
	PY_ATTRIBUTE( loginName )
	/*~ attribute ClientApp loginPassword
	*  @components{ bots }
	*  The password used by the simulated client.
	*  @type Read-only string
	*/
	PY_ATTRIBUTE( loginPassword )
	/*~ attribute ClientApp tag
	*  @components{ bots }
	*  The tag name associated with the simulated client.
	*  @type string
	*/
	PY_ATTRIBUTE( tag )
	/*~ attribute ClientApp speed
	*  @components{ bots }
	*  The speed of the player entity controlled by the simulated client.
	*  @type float
	*/
	PY_ATTRIBUTE( speed )
	/*~ attribute ClientApp position
	*  @components{ bots }
	*  The position of the player entity of the simulated client.
	*  @type Vector3
	*/
	PY_ATTRIBUTE( position )
	/*~ attribute ClientApp yaw
	*  @components{ bots }
	*  The yaw (direction) of the player entity of the simulated client.
	*  @type Vector3
	*/
	PY_ATTRIBUTE( yaw )
	/*~ attribute ClientApp pitch
	*  @components{ bots }
	*  The pitch (direction) of the player entity of the simulated client.
	*  @type Vector3
	*/
	PY_ATTRIBUTE( pitch )
	/*~ attribute ClientApp roll
	*  @components{ bots }
	*  The roll (direction) of the player entity of the simulated client.
	*  @type Vector3
	*/
	PY_ATTRIBUTE( roll )
	/*~ attribute ClientApp entities
	*  @components{ bots }
	*  entities contains a list of all the entities which currently within
	*  the player entity's AOI.
	*
	*  @type Read-only PyEntities
	*/
	PY_ATTRIBUTE( entities )
	/*~ attribute ClientApp autoMove
	*  @components{ bots }
	*  The flag indicates whether the player entity is moving automatically.
	*  (either under movement controller or random movement.
	*  @type boolean
	*/
	PY_ATTRIBUTE( autoMove )
	/*~ attribute ClientApp isOnline
	*  @components{ bots }
	*  Indicates whether the simulated client is connected to a BigWorld server.
	*  @type Read-only boolean
	*/
	PY_ATTRIBUTE( isOnline )
	/*~ attribute ClientApp isMoving
	*  @components{ bots }
	*  Indicates whether the player entity under controlled of the simulated 
	*  client is moving.
	*  @type Read-only boolean
	*/
	PY_ATTRIBUTE( isMoving )
	/*~ attribute ClientApp isDestroyed
	*  @components{ bots }
	*  Indicates whether player entity of the simulated client has been
	*  destroyed.
	*  @type Read-only boolean
	*/
	PY_ATTRIBUTE( isDestroyed )
PY_END_ATTRIBUTES()

/*~ callback Entity.onTick
 *  @components{ bots }
 *  If present, this method is called every game tick on the entity
 *  while the client is connected to a BigWorld server. This facilitates
 *  custom game logic implementation.
 */

// -----------------------------------------------------------------------------
// Section: Construction/Destruction
// -----------------------------------------------------------------------------

/**
 *	Constructor.
 */
ClientApp::ClientApp( const std::string & name, const std::string & password, 
					   const std::string & tag, PyTypeObject * pType ) :
	PyObjectPlus( pType ),
	serverConnection_(),
	spaceID_( 0 ),
	playerID_( 0 ),
	pLoginInProgress_( NULL ),
	isDestroyed_( false ),
	isDormant_( true ),
	userName_( name ),
	userPasswd_( password ),
	tag_( tag ),
	speed_( 6.f + float(rand())*2.f/float(RAND_MAX) ),
	pMovementController_( NULL ),
	autoMove_( true ),
	pDest_( NULL ),
	hasPlayerControl_( true )
{
	pEntities_ = new PyEntities( this );

	this->logOn();
}

void ClientApp::logOn()
{
	if (isDestroyed_)
		return;

	isDormant_ = false;

	if ((pLoginInProgress_ != NULL) || serverConnection_.online())
		return;

	MainApp & app = app.instance();

	serverConnection_.pTime( &app.localTime() );

	// check digest
	MD5::Digest digest = app.digest();
	bool emptyDigest = true;
	for (uint32 i = 0; i < sizeof( digest ); i++)
	{
		if (digest.bytes[i] != '0')
		{
			emptyDigest = false;
			break;
		}
	}

	if (!emptyDigest)
		serverConnection_.digest( digest );

	TRACE_MSG( "Connecting to server at %s\n", 
		BotsConfig::serverName().c_str() );

	serverConnection_.pLogOnParamsEncoder( app.pLogOnParamsEncoder() );

	pLoginInProgress_ = serverConnection_.logOnBegin(
		BotsConfig::serverName().c_str(),
		userName_.c_str(),
		userPasswd_.c_str() );
}

void ClientApp::logOff()
{
	if (serverConnection_.online())
	{
		serverConnection_.send(); // make sure last bundle is pushed to server
		serverConnection_.disconnect();
	}
}

void ClientApp::dropConnection()
{
	// TODO: calling this function will hit an assertion
	// MF_ASSERT_DEV FAILED: !p->shouldCreateAnonymous() in nub.cpp
	// This is expected since we abruptly drop the connection (and deleting
	// corresponding channel). It will trigger dropped packet routine check as
	// data still get pumped from the server.
	// I believe the easiest way to fix this is removing the dev assert.
	// However, I don't want change any other code other than bots at this
	// moment.
	if (serverConnection_.online())
	{
		serverConnection_.disconnect( false );
	}
}

void ClientApp::setConnectionLossRatio( float lossRatio )
{
	if (lossRatio < 0.0 || lossRatio > 1.0)
	{
		PyErr_Format( PyExc_ValueError, "Loss ratio for connection "
			"should be within [0.0 - 1.0]" );
		return;
	}
	serverConnection_.networkInterface().setLossRatio( lossRatio );
}

void ClientApp::setConnectionLatency( float latencyMin, float latencyMax )
{
	// TODO: add more checking and make it more sophisticated.
	if (latencyMin >= latencyMax)
	{
		PyErr_Format( PyExc_ValueError,
			"latency max should be larger than latency min" );
		return;
	}
	serverConnection_.networkInterface().setLatency( latencyMin, latencyMax );
}

/**
 *	Destructor.
 */
ClientApp::~ClientApp()
{
	if (!isDestroyed_)
		this->destroy();
}

// -----------------------------------------------------------------------------
// Section: Python related
// -----------------------------------------------------------------------------

/**
 *	This method overrides the PyObjectPlus method to get a Python attribute of
 *	this object.
 */
PyObject * ClientApp::pyGetAttribute( const char * attr )
{
	PY_GETATTR_STD();
	return PyObjectPlus::pyGetAttribute( attr );
}

/**
 *	This method overrides the PyObjectPlus method to set a Python attribute of
 *	this object.
 */
int ClientApp::pySetAttribute( const char * attr, PyObject * value )
{
	PY_SETATTR_STD();
	return PyObjectPlus::pySetAttribute( attr, value );
}


/**
 *	This method is called when the base part of the player has been created.
 */
void ClientApp::onBasePlayerCreate( EntityID id, EntityTypeID type,
	BinaryIStream & data )
{
	//TRACE_MSG( "ClientApp::onBasePlayerCreate(%08x): id = %d\n", (int)this, id );
	playerID_ = id;
	spaceID_ = 0;

	// Create the entity no matter it is scriptable or not,
	// so we can logoff the entity from server on bot deletion
	EntityType * pType = EntityType::find( type );
	MF_ASSERT( pType );

	MF_ASSERT( entities_.find( id ) == entities_.end() );

	this->entities_[ id ] = pType->newEntity( *this,
		id, Vector3::zero(), 0, 0, 0, data, /*isBasePlayer:*/true );
}


/**
 *	This method is called when the cell part of the player has been created.
 */
void ClientApp::onCellPlayerCreate( EntityID id,
	SpaceID spaceID, EntityID vehicleID, const Position3D & pos,
	float yaw, float pitch,	float roll,
	BinaryIStream & data )
{
	//TRACE_MSG( "ClientApp::onCellPlayerCreate: id = %d\n", id );
	if (BotsConfig::shouldUseScripts())
	{
		MF_ASSERT( id == playerID_ );

		Entity * pPlayer = this->entities_[ id ];
		MF_ASSERT( pPlayer );
		pPlayer->readCellPlayerData( data );
	}

	spaceID_ = spaceID;
	position_ = pos;
	direction_.yaw = yaw;
	direction_.pitch = pitch;
	direction_.roll = roll;

	pMovementController_ =
		MainApp::instance().createDefaultMovementController( speed_, position_);

	if (PyErr_Occurred())
	{
		PyErr_Print();
	}

	data.finish(); // Avoid message about data still being on the stream
}


/**
 *	This method is called when an entity enters the client's AOI.
 */
void ClientApp::onEntityEnter( EntityID id, SpaceID spaceID, EntityID )
{
	//TRACE_MSG( "ClientApp::onEntityEnter(%d): entityID = %d\n", playerID_, id );

	if (BotsConfig::shouldUseScripts())
	{
		if (id != playerID_)
		{
			EntityMap::iterator iter = this->entities_.find( id );
			if (iter != this->entities_.end())
			{
// 				TRACE_MSG( "ClientApp::onEntityEnter(%d): entityID %d is in cache\n",
// 					playerID_, id);

				serverConnection_.requestEntityUpdate( id, iter->second->cacheStamps() );
			}
			else
			{
// 				TRACE_MSG( "ClientApp::onEntityEnter(%d): entityID %d is new\n",
// 					playerID_, id );

				serverConnection_.requestEntityUpdate( id );
			}
		}
	}
	else
	{
		serverConnection_.requestEntityUpdate( id );
	}
}


/**
 *	This method is called when an entity leaves the client's AOI.
 */
void ClientApp::onEntityLeave( EntityID id, const CacheStamps & stamps )
{
	//TRACE_MSG( "ClientApp::onEntityLeave(%d): entityID = %d\n", playerID_, id );
	EntityMap::iterator iter = this->entities_.find( id );
	if (iter != this->entities_.end())
	{
		if (iter->second)
		{
			iter->second->destroy();
			Py_DECREF( iter->second );
		}
		this->entities_.erase( iter );
	}
	else
	{
		// __glenc__: Disabling this warning because this can happen if a
		// leave message is recvd before the reply to requestEntityUpdate.
		// Since the client-side caching system is disabled, we should just
		// remove 'enterAoI' and have the server send 'createEntity' the
		// first time.
// 			WARNING_MSG("ClientApp::onEntityLeave(%d): "
// 				"cannot find entityID %d\n", playerID_, id);
	}
}

/**
 *	This method is called by the server in response to a
 *	requestEntityUpdate.
 */
void ClientApp::onEntityCreate( EntityID id, EntityTypeID type,
	SpaceID spaceID, EntityID vehicleID, const Position3D & pos,
	float yaw, float pitch,	float roll,
	BinaryIStream & data )
{
	//TRACE_MSG( "ClientApp::onEntityCreate(%d): entityID = %d\n", playerID_, id );
	// Make sure it doesn't already exist.
	if (this->entities_.find( id ) != this->entities_.end())
	{
		ERROR_MSG( "ClientApp::onEntityCreate(%d): "
				"entity(id = %d) already exists\n", playerID_, id );

		data.finish();
	}
	else
	{
		EntityType * pEntityType = EntityType::find( type );
		if (pEntityType == NULL)
		{
			ERROR_MSG( "ClientApp::onEntityCreate(%d): "
					"entity type %d doesn't exist for bots\n", playerID_, (int)type );
			return;
	    }
		Vector3 vectPos (pos);
		if (BotsConfig::shouldUseScripts())
		{
			// now, entity is only created when it is
			// required for running corresponding script.
			this->entities_[ id ] = pEntityType->newEntity( *this,
				id, vectPos, yaw, pitch, roll, data, /*isBasePlayer:*/false );
		}
		else
		{
			this->entities_[ id ] = NULL;
			data.finish();
		}
	}
}

/**
 *	This method is called by the server to update some properties of
 *	the given entity, while it is in our AoI.
 */
void ClientApp::onEntityProperties( EntityID id, BinaryIStream & data )
{
	//TRACE_MSG( "ClientApp::onEntityProperties(%d): entityID = %d\n", playerID_, id );
	if (BotsConfig::shouldUseScripts())
	{
		// unimplemented since this client does not support detail levels
		// (currently the only cause of this message)
		EntityMap::iterator iter = this->entities_.find( id );
		if (iter != this->entities_.end())
		{
			iter->second->updateProperties( data );
		}
		else
		{
			ERROR_MSG( "ClientApp::onEntityProperties(Bot %d): entity(id = %d) not found\n",
						playerID_, id );
		}
	}
	else
	{
		data.finish(); // Avoid message about data still being on the stream
	}
}


/**
 *	This method is called when the server sets a property on an entity.
 */
void ClientApp::onEntityProperty( EntityID entityID, int propertyID,
	BinaryIStream & data )
{
	//TRACE_MSG( "ClientApp::onEntityProperty(%d:%08x): entityID = %d\n", playerID_, (int)this, entityID );
	if (BotsConfig::shouldUseScripts())
	{
		EntityMap::iterator iter = this->entities_.find( entityID );
		if ( iter != this->entities_.end() )
		{
			iter->second->handlePropertyChange( propertyID , data );
		}
		else
		{
			// this could be a message for an entity that has not yet been
			// loaded, or has already been unloaded.
		}
	}
	else
	{
		data.finish(); // Avoid message about data still being on the stream
	}
}


/**
 *	This method is called when the server calls a method on an entity.
 */
void ClientApp::onEntityMethod( EntityID entityID, int methodID,
	BinaryIStream & data )
{
	//TRACE_MSG( "ClientApp::onEntityMethod(%d): entityID = %d\n", playerID_, entityID );
	if (BotsConfig::shouldUseScripts())
	{
		EntityMap::iterator iter = this->entities_.find( entityID );
		if ( iter != this->entities_.end() )
		{
			iter->second->handleMethodCall( methodID , data );
		}
		else
		{
			// this could be a message for an entity that has not yet been
			// loaded, or has already been unloaded.
		}
	}
	else
	{
		data.finish(); // Avoid message about data still being on the stream
	}
}


/**
 *	This method is called when the position of an entity changes.
 */
void ClientApp::onEntityMove( EntityID entityID, SpaceID spaceID, EntityID vehicleID,
	const Position3D & pos,	float yaw, float pitch, float roll,
	bool isVolatile )
{
	//TRACE_MSG( "ClientApp::onEntityMove(%d): entityID = %d\n", playerID_, entityID );
	if (entityID == playerID_)
	{
		spaceID_ = spaceID;
		position_ = pos;
		direction_.yaw = yaw;direction_.pitch = pitch; direction_.roll = roll;
		vehicleID_ = vehicleID;
		if (hasPlayerControl_)
		{
			serverConnection_.addMove( entityID, spaceID, vehicleID,
				pos, yaw, pitch, roll, false, pos );
		}
	}

	if (BotsConfig::shouldUseScripts() &&
		this->entities_.find( entityID ) != this->entities_.end())
	{
		this->entities_[ entityID ]->position( pos );
	}
}

void ClientApp::onEntityControl( EntityID id, bool control )
{
	if (id == playerID_)
	{
		hasPlayerControl_ = control;
		INFO_MSG( "Bot %d %s of the player\n", id,
			control ? "is in control" : "loses control" );
	}
}

/**
 *	This method is called to set the current time of day.
 */
void ClientApp::setTime( GameTime gameTime,
		float initialTimeOfDay, float gameSecondsPerSecond )
{
	//TRACE_MSG( "ClientApp::setTime(%d)\n", playerID_ );
}


/**
 *	This method is called when data associated with a space is received.
 */
void ClientApp::spaceData( SpaceID spaceID, SpaceEntryID entryID, uint16 key,
	const std::string & data )
{
	//TRACE_MSG( "ClientApp::spaceData(%d): spaceID = %d\n", playerID_, spaceID );
	SpaceDataManager & spaceDataManager = 
		MainApp::instance().spaceDataManager();
	SpaceData * pSpace = spaceDataManager.findOrAddSpaceData( spaceID );

	if (!pSpace)
		return;

	SpaceData::EntryStatus entryStat = pSpace->dataEntry( entryID, key, data );

	// Actually, for client friendliness, we'll parse the data ourselves here.
	if (key == SPACE_DATA_TOD_KEY)
	{
		// TODO:: expose current game time for the space, if it is required.
		// todData.initialTimeOfDay, todData.gameSecondsPerSecond;
		/*
		const std::string * pData =
			pSpace->dataRetrieveFirst( SPACE_DATA_TOD_KEY );
		if (pData != NULL && pData->size() >= sizeof(SpaceData_ToDData))
		{
			SpaceData_ToDData & todData = *(SpaceData_ToDData *)pData->data();
		}
		*/
	}
/*
	else if (key == SPACE_DATA_WEATHER)
	{
		Script::call(
			PyObject_GetAttrString( Personality::instance(), "onWeatherChange" ),
			Py_BuildValue( "(is)", spaceID, data.c_str() ), "EntityManager::spaceData weather notifier: ", true );
	}
*/
	else if (key == SPACE_DATA_MAPPING_KEY_CLIENT_SERVER ||
			 key == SPACE_DATA_MAPPING_KEY_CLIENT_ONLY)
	{
		// We are not very interested in space geometry data
		// at this moment.
	}
	else // give script a chance to handle space data
	{
		PyObjectPtr pModule = MainApp::instance().getPersonalityModule();
		if (entryStat == SpaceData::DATA_ADDED)
		{
			Script::call(
				PyObject_GetAttrString( pModule.getObject(),
					"onSpaceDataCreated" ),
				Py_BuildValue( "(iis)", spaceID, key, data.c_str() ),
				"onSpaceDataCreated", true );
		}
		else if (entryStat == SpaceData::DATA_DELETED)
		{
			Script::call(
				PyObject_GetAttrString( pModule.getObject(),
					"onSpaceDataDeleted" ),
				Py_BuildValue( "(iO)", spaceID, Script::getData( entryID ) ),
				"onSpaceDataDeleted", true );
		}
		else if (entryStat == SpaceData::DATA_MODIFIED)
		{
			Script::call(
				PyObject_GetAttrString( pModule.getObject(),
					"onSpaceDataModified" ),
				Py_BuildValue( "(iis)", spaceID, key, data.c_str() ),
				"onSpaceDataModified", true );
		}
	}
}

/**
 *	This method is called when the given space is no longer visible to the
 *	client.
 */
void ClientApp::spaceGone( SpaceID spaceID )
{
	//TRACE_MSG( "ClientApp::spaceGone(%d): spaceID = %d\n", playerID_, spaceID );
}

/**
 *	This method is called when proxy data is received.
 */
void ClientApp::onProxyData( uint16 proxyDataID, BinaryIStream & data )
{
	TRACE_MSG( "ClientApp::onProxyData: id %04X, data '%.*s'\n",
		proxyDataID, data.remainingLength(),
		(char *)data.retrieve( data.remainingLength() ) );
}

/*
 *	Override from ServerMessageHandler.
 *  This method is called when the server tells us to reset all our
 *  entities. The player entity may optionally be saved (but still should
 *  not be considered to be in the world).
 *
 *  This can occur when the entity that the client is associated with
 *  changes or when the current client destroys its cell entity.
 */
void ClientApp::onEntitiesReset( bool keepPlayerOnBase )
{
	TRACE_MSG( "ClientApp::onEntitiesReset(%d): keepPlayerOnBase = %s\n",
				playerID_, keepPlayerOnBase ? "TRUE" : "FALSE" );

	spaceID_ = 0;

	EntityMap::iterator iterToDel;
	EntityMap::iterator iter = this->entities_.begin();
	while (iter != this->entities_.end())
	{
		Entity * pCurr = iter->second;
		iterToDel = iter;
		++iter;

		if (pCurr) {
			if (pCurr->id() == playerID_ &&
				keepPlayerOnBase)
			{
				continue;
			}
			pCurr->destroy();
			Py_DECREF( pCurr );
		}
		this->entities_.erase(iterToDel);
	}

	if (!keepPlayerOnBase)
	{
		playerID_ = 0;
	}
}


/**
 *  Override from ServerMessageHandler, done for testing streaming downloads to
 *  multiple clients.
 */
void ClientApp::onStreamComplete( uint16 id, const std::string &desc,
	BinaryIStream &data )
{
	INFO_MSG( "Streaming download #%d complete: %s (%d bytes)\n",
		id, desc.c_str(), data.remainingLength() );

	data.finish();
}


// -----------------------------------------------------------------------------
// Section: General interface
// -----------------------------------------------------------------------------

/**
 *	This method is called every tick (probably 100 milliseconds).
 */
bool ClientApp::tick( float dTime )
{
	// if it is dormant skip call tick.
	if (isDormant_)
		return true;

	serverConnection_.processInput();

	// if there is a login in progress see if we can complete it
	if (pLoginInProgress_)
	{
		if (pLoginInProgress_->done())
		{
			LogOnStatus status =
				serverConnection_.logOnComplete( pLoginInProgress_, this );

			pLoginInProgress_ = NULL;

			if (!status.succeeded())
			{
				ERROR_MSG( "LogOn failed (%s)\n",
						serverConnection_.errorMsg().c_str() );
				return false;
			}
			else
			{
				if (serverConnection_.online())
				{
					serverConnection_.enableEntities();
				}
			}
		}
		return true;
	}

	if (!serverConnection_.online())
	{
		//clear entity maps first
		for (EntityMap::iterator iter = entities_.begin();
			iter != entities_.end(); iter++)
		{
			if (iter->second)
			{
				iter->second->destroy();
				Py_DECREF( iter->second );
			}	
		}
		entities_.clear();

		if (pMovementController_)
		{
			delete pMovementController_;
			pMovementController_= NULL;
		}

		// allow script to decide we shall self-destruct or
		// still be alive so that we may reattempt log in.

		PyObjectPtr pModule = MainApp::instance().getPersonalityModule();

		if (pModule && (playerID_ != 0))
		{
			PyObject * pResult = Script::ask(
				PyObject_GetAttrString( pModule.getObject(),
				"onLoseConnection" ),
				Py_BuildValue( "(i)", playerID_ ),
				"onLoseConnection", true, true );

			spaceID_ = 0;
			playerID_ = 0;
			vehicleID_ = 0;

			if (pResult != NULL)
			{
				// if the script return true, it shall be destroyed.
				bool toBeDestroyed = (PyObject_IsTrue( pResult ) == 0);
				Py_DECREF( pResult );
				isDormant_ = toBeDestroyed;
				return toBeDestroyed;
			}
			else
			{
				PyErr_Print();
			}
		}
		spaceID_ = 0;
		playerID_ = 0;
		vehicleID_ = 0;
		return false;
	}

	if (dTime > 0.f && spaceID_ != 0)
	{
		if (BotsConfig::shouldUseScripts())
		{
			Entity * pPlayer = this->entities_[ playerID_ ];
			MF_ASSERT( pPlayer );

			PyObject * pFn = PyObject_GetAttrString( pPlayer, "onTick" );

			if (pFn)
			{
				PyObject * pResult = PyObject_CallFunction( pFn, "d",
					serverConnection_.serverTime(
					MainApp::instance().localTime() ) );

				if (pResult != NULL)
				{
					Py_DECREF( pResult );
				}
				else
				{
					PyErr_Print();
				}
				Py_DECREF( pFn );
			}
			else
			{
				PyErr_Clear();
			}
			// Handle any user timeouts
			this->processTimers();
		}

		if (hasPlayerControl_)
		{
			// Movement ordered by moveTo() takes precedence over
			// movement by movement controller
			if (pDest_ != NULL)
			{
				const float closeEnough = 1.0;
				Vector3 displacement = *pDest_ - position_;
				float length = displacement.length();

				if (length < closeEnough)
				{
					delete pDest_;
					pDest_ = NULL;
				}
				else
				{
					displacement *= speed_ * dTime / length;
					position_ += displacement;
					direction_.yaw = displacement.yaw();
					serverConnection_.addMove(
						playerID_, spaceID_, 0,	position_,
						direction_.yaw,	0, 0, true, position_ );
				}

			}
			else if (autoMove_)
			{
				this->addMove( dTime );
			}
		}
		else if (pDest_)
		{
			// since we don't have control of the player
			// remove any destination
			delete pDest_;
			pDest_ = NULL;
		}
	}
	serverConnection_.send();
	return true;
}


/**
 *	This method sends a movement message to the server.
 */
void ClientApp::addMove( double dTime )
{
	if (isDestroyed_ || !hasPlayerControl_)
		return;

	if (pMovementController_)
	{
		pMovementController_->nextStep( speed_, dTime, position_, direction_ );
		serverConnection_.addMove( playerID_, spaceID_, 0, position_,
				direction_.yaw, direction_.pitch, direction_.roll,
				true, position_ );
	}
	else
	{
		double time = MainApp::instance().localTime();
		const float period = 10.f * speed_ / 7.f;
		const float radius = 10.f;
		const float angle = time * 2 * MATH_PI / period;

		Vector3 position( position_.x + radius * sinf( angle ),
						  0.f,
						  position_.z + radius * cosf( angle ) );

		serverConnection_.addMove( playerID_, spaceID_, 0, position,
				angle + MATH_PI/2.f, 0.f, 0.f, true, position );
	}
}


/**
 *	This method sets a new movement controller for this bot. On failure, the
 *	controller is left unchanged.
 *
 *	@return True on success, otherwise false.
 */
bool ClientApp::setMovementController( const std::string & type,
		const std::string & data )
{
	if (isDestroyed_)
		return false;

	MovementController * pNewController =
		MainApp::instance().createMovementController(
			speed_, position_, type, data );

	if (PyErr_Occurred())
	{
		return false;
	}

	if (pMovementController_ != NULL)
		delete pMovementController_;

	pMovementController_ = pNewController;
	return true;
}

void ClientApp::moveTo( const Vector3 &pos )
{
	if (isDestroyed_ || !hasPlayerControl_) // TODO: should add a warning message if we are not in control
		return;

	// make sure no memory leak if called repeatedly from script.
	if (pDest_ != NULL)
	{
		pDest_->set( pos.x, pos.y, pos.z );
	}
	else
	{
		pDest_ = new Vector3( pos );
	}

	autoMove_ = false;
}

void ClientApp::faceTowards( const Vector3 &pos )
{
	if (isDestroyed_ || !hasPlayerControl_)
		return;

	direction_.yaw = (pos - position_).yaw();
	serverConnection_.addMove(
		playerID_, spaceID_, 0,	position_,
		direction_.yaw,	0, 0, true, position_ );
}

void ClientApp::stop()
{
	if (isDestroyed_)
		return;

	if (pDest_ != NULL)
	{
		delete pDest_;
		pDest_ = NULL;
	}
	autoMove_ = false;
}

/**
 *  This method adds a timer for this bot.  The callback will be executed during
 *  the next tick after the specified number of seconds has elapsed.  The id of
 *  this timer is returned so it can be cancelled later on with delTimer() if
 *  desired.  A negative return value indicates failure.
 */
int ClientApp::addTimer( float interval, PyObjectPtr pFunc, bool repeat )
{
	if (isDestroyed_)
		return -1;

	PyObjectPtr pFuncPyStr( PyObject_Str( pFunc.getObject() ),
		PyObjectPtr::STEAL_REFERENCE );
	char *pFuncStr = PyString_AsString( pFuncPyStr.getObject() );

	// Make sure a function or method was passed
	if (!PyCallable_Check( pFunc.getObject() ))
	{
		ERROR_MSG( "ClientApp::addTimer(): %s is not callable; "
			"timer not added\n", pFuncStr );
		return -1;
	}

	// Make new timeRec and insert into the heap of timers
	TimerRec tr( interval, pFunc, repeat );
	timerRecs_.push( tr );
	return tr.id();
}

/**
 *  This method deletes a timer for this bot.  It actually just adds the timer
 *  ID to a list of timers to be ignored so when the timer finally expires its
 *  callback is not executed.
 */
void ClientApp::delTimer( int id )
{
	if (isDestroyed_)
		return;
	deletedTimerRecs_.push_back( id );
}

void ClientApp::processTimers()
{
	// Process any timers that have elapsed
	while (!timerRecs_.empty() && timerRecs_.top().elapsed())
	{
		TimerRec tr = timerRecs_.top();
		timerRecs_.pop();

		// Check if it has been deleted, if so just ignore it
		std::list< int >::iterator iter = std::find( deletedTimerRecs_.begin(),
			deletedTimerRecs_.end(), tr.id() );
		if (iter !=	deletedTimerRecs_.end())
		{
			deletedTimerRecs_.erase( iter );
			continue;
		}

		PyObject *pResult = PyObject_CallFunction( tr.func(), "" );

		if (pResult != NULL)
		{
			Py_DECREF( pResult );
		}
		else
		{
			PyErr_Print();
		}

		// Re-insert the timer into the queue if it's on repeat
		if (tr.repeat())
		{
			tr.restart();
			timerRecs_.push( tr );
		}
	}
}


/**
 *	This method destroys this ClientApp.
 */
void ClientApp::destroy()
{
	if (!isDestroyed_)
	{
		isDestroyed_ = true;

		PyObjectPtr pModule = MainApp::instance().getPersonalityModule();

		if (pModule && (playerID_ != 0))
		{
			Script::call(
				PyObject_GetAttrString( pModule.getObject(),
						"onClientAppDestroy" ),
					Py_BuildValue( "(i)", playerID_ ),
					"onClientAppDestroy", true );
		}

		if (serverConnection_.online())
		{
			this->logOff();
		}

		//clear entity maps
		for (EntityMap::iterator iter = entities_.begin();
				iter != entities_.end(); iter++)
		{
			if (iter->second)
			{
				iter->second->destroy();
				Py_DECREF( iter->second );
			}
		}
		entities_.clear();
		Py_XDECREF( pEntities_ );

		spaceID_ = 0;
		playerID_ = 0;
		vehicleID_ = 0;

		if (pMovementController_)
		{
			delete pMovementController_;
			pMovementController_= NULL;
		}
	}
}


// -----------------------------------------------------------------------------
// Section: TimerRec stuff
// -----------------------------------------------------------------------------
int ClientApp::TimerRec::ID_TICKER = 0;

// client_app.cpp
