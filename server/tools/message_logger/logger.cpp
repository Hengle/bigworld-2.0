/******************************************************************************
BigWorld Technology 
Copyright BigWorld Pty, Ltd.
All Rights Reserved. Commercial in confidence.

WARNING: This computer program is protected by copyright law and international
treaties. Unauthorized use, reproduction or distribution of this program, or
any portion of this program, may result in the imposition of civil and
criminal penalties as provided by law.
******************************************************************************/

#include "logger.hpp"

#include "bwlog_writer.hpp"
#include "constants.hpp"
#include "mlutil.hpp"
#include "user_log.hpp"

#include "cstdmf/debug.hpp"
#include "cstdmf/dprintf.hpp"
#include "cstdmf/timestamp.hpp"

#include "network/logger_message_forwarder.hpp"
#include "network/machined_utils.hpp"
#include "network/network_interface.hpp"
#include "network/portmap.hpp"

#include "server/bwconfig.hpp"
#include "server/bwservice.hpp"
#include "server/config_reader.hpp"

#include <time.h>

#ifdef _WIN32
#define snprintf _snprintf
#endif

#ifdef _WIN32
#define unlink _unlink
#endif

#ifdef unix
#include "pwd.h"
#endif

#include <algorithm>

DECLARE_DEBUG_COMPONENT( 0 )

namespace // anonymous
{

const char * USAGE_MESSAGE =
	"\n"
	"Usage: logger [options] [outdir]\n"
	"options:\n"
	" -h, --help    Print this message and exit.\n"
	" -u UID        Log only messages from processes run by the user\n"
	"                with uid = UID. If UID is \"all\", messages from\n"
	"                all users will be logged. If no uid is specified,\n"
	"                processes by all users will be logged.\n"
	" -p NAME       Log messages from processes with name NAME. Multiple\n"
	"                names may be specified using multiple -p options. By\n"
	"                default, messages from processes of any name are\n"
	"                logged. Appropriate names include: CellAppMgr, CellApp,\n"
	"                BaseApp, BaseAppMgr, DBMgr, LoginApp, WPGen. -p and\n"
	"                -d options can not be used at same time.\n"
	" -d NAME       Do not log messages from processes with name NAME.\n"
	"                Multiple names may be specified using multiple -d\n"
	"                options. By default messages from processes of any\n"
	"                name are logged. -d and -p options can not be used\n"
	"                at same time.\n"
	" -l LoggerID   If set, log only messages destined for this LoggerID.\n"
	" -v            Verbose mode. Prints all messages to standard output.\n"
	" --version     Display version information.\n"
	" --daemon      Run as daemon.\n"
	" -c|--config <conffile>\n"
	"               Specify config file to use.\n"
	" -t|--text     Generate text logs as well as binary logs\n"
	" -q|--quiet    Quiet Mode. Do not display message generated by this\n"
	"               process. By default, these are output to standard error.\n"
	" -o filename	Redirect standard output to filename.\n"
	" -e filename	Redirect standard error to filename.\n"
	" -[TRACE|DEBUG|INFO|NOTICE|WARNING|ERROR|CRITICAL|HACK|SCRIPT]\n"
	"               Disable logging of specific type of message.\n"
	" +[TRACE|DEBUG|INFO|NOTICE|WARNING|ERROR|CRITICAL|HACK|SCRIPT]\n"
	"               Enable logging of specific type of message. The first\n"
	"               option of this type disables logging of other messages.\n"
	"\n"
	"outdir         Output will be stored in this directory.\n";

// -----------------------------------------------------------------------------
// Section: Logger
// -----------------------------------------------------------------------------

Logger * g_pInstance_;

	// The number of seconds until the [Groups] from a machine should be
	// requeried to ensure they haven't changed.
const uint SECONDS_TILL_GROUP_REQUERY = 60;

const uint8 OLDEST_SUPPORTED_MESSAGE_LOGGER_VERSION = 6;

} // end anonymous namespace


/**
 *	Constructor.
 */
Logger::Logger() :
	WatcherRequestHandler(),
	watcherNub_(),
	dispatcher_(),
	loggerID_(),
	logUser_( getUserId() ),
	logAllUsers_( true ),
	logNames_(),
	doNotLogNames_(),
	quietMode_( true ),
	daemonMode_( false ),
	shouldRoll_( false ),
	addLoggerData_(),
	delLoggerData_(),
	components_(),
	pLogWriter_( new BWLogWriter() )
{
	g_pInstance_ = this;

	for (int i = 0; i < NUM_MESSAGE_PRIORITY; ++i)
		shouldLogMessagePriority_[ i ] = true;

	MF_WATCH( "size", *this, &Logger::size );
	MF_WATCH( "reattachAll", *this,
			MF_ACCESSORS( bool, Logger, commandReattachAll ) );
	{
		MF_WATCH( "filter/threshold", DebugFilter::instance(),
				MF_ACCESSORS( int, DebugFilter, filterThreshold ) );
		MF_WATCH( "filter/TRACE",    shouldLogMessagePriority_[ 0 ] );
		MF_WATCH( "filter/DEBUG",    shouldLogMessagePriority_[ 1 ] );
		MF_WATCH( "filter/INFO",     shouldLogMessagePriority_[ 2 ] );
		MF_WATCH( "filter/NOTICE",   shouldLogMessagePriority_[ 3 ] );
		MF_WATCH( "filter/WARNING",  shouldLogMessagePriority_[ 4 ] );
		MF_WATCH( "filter/ERROR",    shouldLogMessagePriority_[ 5 ] );
		MF_WATCH( "filter/CRITICAL", shouldLogMessagePriority_[ 6 ] );
		MF_WATCH( "filter/HACK",     shouldLogMessagePriority_[ 7 ] );
		MF_WATCH( "filter/SCRIPT",   shouldLogMessagePriority_[ 8 ] );
	}

	Watcher::rootWatcher().addChild( "components",
		new MapWatcher< Components >( components_ ) );
	Watcher::rootWatcher().addChild( "components/*", &Component::watcher() );
}


/**
 * This method initialises the logger.
 *
 * @return true on success, otherwise false.
 */
bool Logger::init( int argc, char * argv[] )
{
	interfaceName_ = BWConfig::get(
		"message_logger/monitoringInterface",
		BWConfig::get( "monitoringInterface",
			Mercury::NetworkInterface::USE_BWMACHINED ) );

	// This string collects interface discovery information to be displayed
	// once file descriptors have been re-assigned to log files when running
	// in daemon mode.
	std::string ifProbeStr;

	if (interfaceName_ == Mercury::NetworkInterface::USE_BWMACHINED)
	{
		// Creating a temporary Nub to query bwmachined for what it
		// knows to be the internalInterface.
		u_int32_t addr;
		Mercury::MachineDaemon::queryForInternalInterface( addr );
		interfaceName_ = inet_ntoa( (struct in_addr &)addr );
		ifProbeStr.append( "Discovered network interface '" );
		ifProbeStr.append( interfaceName_.c_str() );
		ifProbeStr.append( "'\n" );
	}

	if (interfaceName_.empty())
	{
		ifProbeStr.append(
			"Logger::init: Assuming monitoringInterface of eth0\n" );
		interfaceName_ = "eth0";
	}

	ifProbeStr.append( "Logger::init: interfaceName = '" );
	ifProbeStr.append( interfaceName_.c_str() );
	ifProbeStr.append( "'\n" );
	watcherNub_.init( interfaceName_.c_str(), 0 );
	watcherNub_.attachTo( dispatcher_ );

	u_int16_t localPort = 0;
	u_int32_t localIP = 0;
	this->socket().getlocaladdress( &localPort, &localIP );
	Mercury::Address localAddr( localIP, localPort );

	// watcherNub_.socket().setnonblocking( false );

	// Set maximum receive buffer size for logger
	int recvbuf;
	FILE *file = fopen( "/proc/sys/net/core/rmem_max", "r" );
	fscanf( file, "%d", &recvbuf );
	fclose( file );
	setsockopt( this->socket(), SOL_SOCKET, SO_RCVBUF,
		(const char *)&recvbuf, sizeof( int ) );

	watcherNub_.setRequestHandler( this );

	bool hadPlusOption = false;
	const char *root = NULL, *config = NULL;

	DebugFilter::shouldWriteToConsole( true );
	DebugFilter::shouldWriteTimePrefix( true );

	// parse command line.
	for (int i=1; i<argc; ++i)
	{
		std::string arg( argv[i] );

		if (argv[i][0] == '-')
		{
			if (arg == "-h" || arg == "--help" )
			{
				DebugFilter::shouldWriteToConsole( true );
				dprintf( USAGE_MESSAGE );
				return false;
			}
			else if ((arg == "-q") || (arg == "--quiet"))
			{
				quietMode_ = true;
				DebugFilter::shouldWriteToConsole( false );
			}
			else if (arg == "-v")
			{
				pLogWriter_->writeToStdout( true );
			}
			else if (arg == "--version")
			{
				const std::string & bwversion = BWVersion::versionString();
				printf( "MessageLogger (BigWorld %s %s. %s %s)\n"
					"Protocol version %d\n"
					"Log format version %d\n", bwversion.c_str(),
					MF_CONFIG, __TIME__, __DATE__,
					MESSAGE_LOGGER_VERSION,
					LOG_FORMAT_VERSION );
					exit( 0 );
			}
			else if (arg == "-p")
			{
				++i;
				if (i >= argc)
				{
					ERROR_MSG( "Invalid command line - no argument for -p\n" );
				}
				else
				{
					logNames_.push_back( argv[i] );
				}
			}
			else if (arg == "-d")
			{
				++i;

				if (i >= argc)
				{
					ERROR_MSG( "Invalid command line - no argument for -d\n" );
				}
				else
				{
					doNotLogNames_.push_back( argv[i] );
				}
			}
			else if (arg == "-o")
			{
				++i;

				if (i >= argc)
				{
					ERROR_MSG( "Invalid command line - no file specified for -o\n" );
					return false;
				}
				else
				{
					outputFilename_ = argv[i];

					if (outputFilename_.c_str()[0] != '/')
					{
						ERROR_MSG( "output filename isn't an absolute path\n" );
						return false;
					}
				}
			}
			else if (arg == "-e")
			{
				++i;

				if (i >= argc)
				{
					ERROR_MSG( "Invalid command line - no file specified for -e\n" );
					return false;
				}
				else
				{
					errorFilename_ = argv[i];

					if (errorFilename_.c_str()[0] != '/')
					{
						ERROR_MSG( "error output filename isn't an absolute path\n" );
						return false;
					}
				}
			}
			else if (arg == "-l")
			{
				++i;

				if (i >= argc)
				{
					ERROR_MSG( "Invalid command line - no argument for -l\n" );
					return false;
				}
				else
				{
					loggerID_.assign( argv[i] );
				}
			}
			else if (arg == "-u")
			{
				++i;
				if (i >= argc)
				{
					ERROR_MSG( "Invalid command line - no argument for -u\n" );
					return false;
				}
				else
				{
					arg = argv[i];
					if (arg == "all")
					{
						logAllUsers_ = true;
					}
					else
					{
						logUser_ = atoi( arg.c_str() );
						logAllUsers_ = false;
					}
				}
			}
			else if (arg == "-c" || arg == "--config")
			{
				++i;
				if (i >= argc)
				{
					ERROR_MSG( "Invalid command line\n" );
					return false;
				}
				else
				{
					config = argv[i];
				}
			}
			else if (arg == "--daemon")
			{
				daemonMode_ = true;
			}
			else
			{
				char buf[ 128 ];
				snprintf( buf, 128, "filter/%s", arg.c_str() + 1 );
				if (!Watcher::rootWatcher().setFromString( NULL, buf, "false" ))
				{
					ERROR_MSG( "Unknown option %s\n", arg.c_str() );
					return false;
				}
			}
		}
		else if (arg[0] == '+')
		{
			if (!hadPlusOption)
			{
				hadPlusOption = true;
				for (int i = 0; i < NUM_MESSAGE_PRIORITY; ++i)
					shouldLogMessagePriority_[ i ] = false;
			}

			char buf[ 128 ];
			snprintf( buf, 128, "filter/%s", arg.c_str() + 1 );
			if (!Watcher::rootWatcher().setFromString( NULL, buf, "true" ))
			{
				ERROR_MSG( "Unknown option %s\n", arg.c_str() );
				return false;
			}
		}
		else
		{
			if (arg[0] != '\0')
				root = argv[i];
		}
	}


	// Use the provided config file otherwise discover where the config file
	// we should be using is located.
	if (config != NULL)
	{
		configFile_ = config;
	}
	else
	{
		// Find the location of the config file we should be using.
		if (!MLUtil::determinePathToConfig( configFile_ ))
		{
			ERROR_MSG( "Logger::init: Unable to determine where to find config "
				"file.\n" );
			return false;
		}
	}

	ConfigReader mlconfig( configFile_.c_str() );
	if (!mlconfig.read())
	{
		ERROR_MSG( "Logger::init: Unable to read configuration file\n" );
		return false;
	}

	std::string value;
	if (mlconfig.getValue( "message_logger", "groups", value ))
	{
		ConfigReader::separateLine( value, ',', groupNames_ );
	}

	if (root && root[0] != '/')
	{
		ERROR_MSG( "Logger::init: Log directory must be an absolute path\n" );
		return false;
	}

#ifndef _WIN32
	if (daemonMode_)
	{
		daemon( 0, int( DebugFilter::shouldWriteToConsole() ) );
	}
#endif

	this->resetFileDescriptors();

	START_MSG( "message_logger" );

	// Now display all the interface discovery information
	{
		int offset = 0;
		int pos = ifProbeStr.find( '\n', offset );
		while ( pos != -1 )
		{
			INFO_MSG( ifProbeStr.substr( offset, (pos + 1) - offset ).c_str() );

			offset = pos + 1;
			pos = ifProbeStr.find( '\n', offset );
		}
	}


	// Display information from option parsing now to avoid corrupting the
	// init.d output.
	if (logAllUsers_)
	{
		INFO_MSG( "Logging all users\n" );
	}
	else
	{
		INFO_MSG( "Logging user id %d\n", logUser_ );
	}

	if (!loggerID_.empty())
	{
		INFO_MSG( "Logging messages destined only for LoggerID: \"%s\"\n",
			loggerID_.c_str() );

		if (loggerID_ == "0")
		{
			// The old 1.9 default, warn if this is not the intended behaviour.
			WARNING_MSG( "Logger::init: Logger ID is set to \"0\", previously "
					"this meant to match all. This behaviour is now specified "
					"by an empty string as the Logger ID.\n" );
		}
	}

	// Have to init the log after the fork() to get the correct PID.
	if (!pLogWriter_->init( mlconfig, root ))
	{
		ERROR_MSG( "Logger::init: BWLog init failed\n" );
		return false;
	}

	// Must start after daemon call so that we get the correct PID.
	{
		if (watcherNub_.registerWatcher(
				0, MESSAGE_LOGGER_NAME, "MessageLogger" ) != 0)
		{
			ERROR_MSG( "Logger::init: Failed to register watcher\n" );
			return false;
		}
	}

	// Register birth and death listeners.
	{
		ListenerMessage lm;
		lm.port_ = localPort;
		lm.category_ = lm.WATCHER_NUB;
		lm.uid_ = lm.ANY_UID;
		lm.pid_ = mf_getpid();
		lm.name_ = ""; // Match everything.

		// Post data is address salt
		uint16 salt = 0;
		lm.postAddr_ = std::string( (char*)&salt, 2 );

		uint32 msgType;

		// We can't use the logger's main socket to do this registration because
		// of the following:
		// 1. We send the registration message with registerWatcher() above.
		// 2. bwmachined2 receives the registration message and calls
		//    broadcastToListeners() which sends a birth notification to itself.
		// 3. We send the birth listener message.
		// 4. The birth listener message is processed.
		// 5. The birth notification bwmachined sent to itself arrives.
		// 6. The birth notification message is sent back to the logger's main
		//    socket.
		// 7. The death listener sendAndRecv() starts and the notification
		//    message is mistakenly processed as a reply, causing the old error:
		//    ERROR: MGMPacket::read: Not enough bytes on stream (wanted 808)

		// The birth listener.
		lm.param_ = lm.PARAM_IS_MSGTYPE | lm.ADD_BIRTH_LISTENER;
		msgType = MESSAGE_LOGGER_PROCESS_BIRTH;
		lm.preAddr_ = std::string( (char*)&msgType, 4 );
		if (lm.sendAndRecvFromEndpointAddr( this->socket(), LOCALHOST ) !=
			Mercury::REASON_SUCCESS)
		{
			ERROR_MSG( "Logger::init: Failed to register birth listener!\n" );
			return false;
		}

		// The death listener.
		lm.param_ = lm.PARAM_IS_MSGTYPE | lm.ADD_DEATH_LISTENER;
		msgType = MESSAGE_LOGGER_PROCESS_DEATH;
		lm.preAddr_ = std::string( (char*)&msgType, 4 );
		if (lm.sendAndRecvFromEndpointAddr( this->socket(), LOCALHOST ) !=
			Mercury::REASON_SUCCESS)
		{
			ERROR_MSG( "Logger::init: Failed to register death listener!\n" );
			return false;
		}
	}

	const char * addPath = "logger/add";
	const int addPathSize = strlen( addPath ) + 1;
	const char * delPath = "logger/del";
	const int delPathSize = strlen( delPath ) + 1;
	const char * localAddrStr = localAddr.c_str();
	const int addrSize = strlen( localAddrStr ) + 1;

	// This is so damn ugly.  An interface for modifying these things should
	// really be written.
	char buf[ 128 ];
	WatcherDataMsg & wdm = *(WatcherDataMsg *)buf;
	wdm.message = WATCHER_MSG_SET;
	wdm.count = 1;
	memcpy( wdm.string, addPath, addPathSize );
	memcpy( wdm.string + addPathSize, localAddrStr, addrSize );
	addLoggerData_.assign( buf, sizeof(wdm) + addPathSize + addrSize );

	memcpy( wdm.string, delPath, delPathSize );
	memcpy( wdm.string + delPathSize, localAddrStr, addrSize );
	delLoggerData_.assign( buf, sizeof(wdm) + delPathSize + addrSize );

	this->initClusterGroups();
	this->initComponents();

	return true;
}


/**
 *	Destructor.
 */
Logger::~Logger()
{
	// Detach all
	{
		// TODO: We should add a timeout so that components attached to the
		// logger will timeout if they haven't received a ping (addComponent)
		// every so often.
		Components::const_iterator iter = components_.begin();

		while (iter != components_.end())
		{
			Mercury::Address addr = iter->first;
			++iter;

			this->delComponent( addr );
		}
	}

	if (pLogWriter_ != NULL)
	{
		delete pLogWriter_;
	}

	g_pInstance_ = NULL;
}


/**
 *	This method processes the next network packet.
 */
bool Logger::handleNextMessage()
{
	// If a log rolling is scheduled, do it now
	if (shouldRoll_)
	{
		if (!pLogWriter_->roll())
		{
			ERROR_MSG( "Logger::handleNextMessage: "
				"Failed to roll component logs\n" );
		}

		this->resetFileDescriptors();

		shouldRoll_ = false;
	}

	return dispatcher_.processOnce( /* shouldIdle: */ true ) != 0;
}


/**
 * Shutdown and re-open any files being used to redirect stdout/stderr.
 *
 * @returns true on success, false on error.
 */
bool Logger::resetFileDescriptors()
{
	int defFlags = O_APPEND | O_CREAT | O_WRONLY;
	mode_t defMode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
	bool status = true;

	// TODO: should we test the open/append/create before daemon so we can
	//      die with some message to stdout
	if (outputFilename_.length())
	{
		int ofd = open( outputFilename_.c_str(), defFlags , defMode );
		if (ofd == -1)
		{
			ERROR_MSG( "Failed to open '%s' for redirecting stdout: %s\n",
						outputFilename_.c_str(), strerror(errno) );
			status = false;
		}
		else
		{
			MF_ASSERT( ofd != 1 );
			// dup2 will now shutdown stdout and duplicate the output file fd.
			if (-1 == dup2( ofd, 1 ))
			{
				ERROR_MSG( "Failed to dup2 '%s' to stdout. %s.\n",
							outputFilename_.c_str(), strerror(errno) );
				status = false;
			}

			// shutdown the temporary fd now that stdout owns it
			close(ofd);
		}
	}


	if (errorFilename_.length())
	{
		if (errorFilename_ == outputFilename_)
		{
			if (-1 == dup2( 1, 2 ))
			{
				ERROR_MSG( "Failed to dup2 stdout to stderr. %s.\n",
							strerror(errno) );
				status = false;
			}
		}
		else
		{
			int efd = open( errorFilename_.c_str(), defFlags, defMode );
			if (efd == -1)
			{
				ERROR_MSG( "Failed to open '%s' for redirecting stderr: %s\n",
							errorFilename_.c_str(), strerror(errno) );
				status = false;
			}
			else
			{

				MF_ASSERT( efd != 2 );
				// dup2 will now shutdown stderr and duplicate
				// the error file fd.
				if (-1 == dup2( efd, 2 ))
				{
					ERROR_MSG( "Failed to dup2 '%s' to stderr. %s.\n",
								errorFilename_.c_str(), strerror(errno) );
					status = false;
				}

				// shutdown the temporary fd now that stderr owns it
				close(efd);
			}
		}
	}

	// Throw an error message so any syslog monitoring will catch the errors
	if (!status)
		ERROR_MSG( "Logging may no longer work." );

	return status;
}


// -----------------------------------------------------------------------------
// Section: Machine Guard
// -----------------------------------------------------------------------------


bool Logger::TagsHandler::onTagsMessage( TagsMessage &tm, uint32 addr )
{
	// Regardless of whether the machine had groups or not, we still
	// need to update the MachineGroups entry.
	MachineGroups *mg = NULL;
	mg = logger_.machineGroups_[ addr ];

	if (mg == NULL)
	{
		mg = new MachineGroups;

		logger_.machineGroups_[ addr ] = mg;
	}

	if (!tm.exists_)
	{
		mg->groups_.clear();
	}
	else
	{
		mg->groups_ = tm.tags_;
	}

	// The last poll time for the machine should be slightly randomised to
	// avoid requerying all machines at the same time.
	mg->lastPollTime_ = (timestamp() / stampsPerSecond()) +
				(int)(10.0 * (rand() / (RAND_MAX + 1.0)));


	return true;
}


bool Logger::FindHandler::onProcessStatsMessage( ProcessStatsMessage &psm, uint32 addr )
{
	if (psm.pid_ == 0)
		return true;

	// We don't want to try to log other message loggers ...
	if (psm.name_ == "message_logger")
		return true;

	Mercury::Address address( addr, psm.port_ );
	if (logger_.sendAdd( address ))
	{
		INFO_MSG( "Logger::onProcessStatsMessage: Found %s at %s. uid = %d\n",
			psm.name_.c_str(), address.c_str(), psm.uid_ );
	}
	return true;
}


/**
 *	This method finds all components that are currently running on the network.
 */
void Logger::initComponents()
{
	ProcessStatsMessage psm;
	psm.param_ = psm.PARAM_USE_CATEGORY;
	psm.category_ = psm.WATCHER_NUB;

	if (!logAllUsers_)
	{
		psm.param_ |= psm.PARAM_USE_UID;
		psm.uid_ = logUser_;
	}

	// Do broadcast and read back replies
	FindHandler handler( *this );
	if (!this->createEndpointAndQueryMsg( psm, BROADCAST, handler ))
	{
		ERROR_MSG( "Logger::initComponents: Failed to find existing cluster "
			"components.\n" );
	}
}


/**
 * Queries the entire cluster for their groups.
 */
void Logger::initClusterGroups()
{
	// No need to query the cluster if we aren't monitoring sub-groups
	if (groupNames_.empty())
	{
		return;
	}

	StringList::const_iterator groupIter = groupNames_.begin();
	std::string groupConcat;
	while (groupIter != groupNames_.end())
	{
		groupConcat.append( *groupIter + " " );
		groupIter++;
	}
	INFO_MSG( "Logger::init: MessageLogger machine groups specified. Only "
		"accepting logs from: %s\n", groupConcat.c_str() );


	// Query the machine for any Groups it has
	TagsMessage tm;
	tm.tags_.push_back( "Groups" );

	TagsHandler handler( *this );
	if (!this->createEndpointAndQueryMsg( tm, BROADCAST, handler ))
	{
		ERROR_MSG( "Logger::initClusterGroups: Unable to query "
			"bwmachined on source of potential logs. " );
	}
}


// -----------------------------------------------------------------------------
// Section: Message handlers
// -----------------------------------------------------------------------------

/**
 *	This method overrides the WatcherRequestHandler method to handle extension
 *	messages.
 */
void Logger::processExtensionMessage( int messageID,
			char * data, int dataLen, const Mercury::Address & addr )
{
	switch (messageID)
	{
		case MESSAGE_LOGGER_MSG:
		{
			MemoryIStream is( data, dataLen );
			this->handleLogMessage( is, addr );

			// Prevent lots of output about memory stream still containing data
			is.finish();

			break;
		}

		case MESSAGE_LOGGER_REGISTER:
		{
			this->handleRegisterRequest( data, dataLen, addr );
			break;
		}

		case MESSAGE_LOGGER_PROCESS_BIRTH:
		{
			if (dataLen == sizeof( Mercury::Address ))
			{
				Mercury::Address addr = *(Mercury::Address *)data;
				this->handleBirth( addr );
			}
			else
			{
				ERROR_MSG( "Logger::processExtensionMessage: "
						"Bad birth size %d\n", dataLen );
			}
			break;
		}

		case MESSAGE_LOGGER_PROCESS_DEATH:
		{
			if (dataLen == sizeof( Mercury::Address ))
			{
				Mercury::Address deadAddr = *(Mercury::Address *)data;

				// If someone sends INADDR_ANY as the address, just use the
				// source address instead
				if (deadAddr.ip == 0)
				{
					deadAddr.ip = addr.ip;
				}

				this->handleDeath( deadAddr );
			}
			else
			{
				ERROR_MSG( "Logger::processExtensionMessage: "
						"Bad death size %d\n", dataLen );
			}
			break;
		}

		case MESSAGE_LOGGER_APP_ID:
		{
			if (dataLen == sizeof( int ))
			{
				pLogWriter_->setAppInstanceID( addr, *(int*)data );
			}
			else
			{
				ERROR_MSG( "Logger::processExtensionMessage: "
					"Bad app ID size %d\n", dataLen );
			}
			break;
		}

		case WATCHER_MSG_TELL:
			// TODO: We may look at these to know whether adds have worked.
			// Ignore tell messages.
			break;

		default:
		{
			DEBUG_MSG( "Logger::processExtensionMessage: "
					"Message %d not handled\n", messageID );

			for (int i = 0; i < dataLen; ++i)
			{
				char c = data[ i ];
				if ((('a' <= c) && (c <= 'z')) ||
						(('A' <= c) && (c <= 'Z')))
				{
					DEBUG_MSG( "%c\n", c );
				}
				else
				{
					DEBUG_MSG( "0x%02d\n", uint8( c ) );
				}
			}

			break;
		}
	}
}

/**
 *	This method is called when a process starts that we may want to watch.
 */
void Logger::handleBirth( const Mercury::Address & addr )
{
}


/**
 *	This method is called when a process stops that we may have been watching.
 */
void Logger::handleDeath( const Mercury::Address & addr )
{
	INFO_MSG( "Logger::handleDeath: %s\n", addr.c_str() );
	this->delComponent( addr, /* send: */ false );
}


/**
 *	This method handles a log message from a component.
 */
void Logger::handleLogMessage( MemoryIStream &is, const Mercury::Address &addr )
{
	Components::const_iterator iter = components_.find( addr );

	if (iter == components_.end())
	{
		WARNING_MSG( "Logger::handleLogMessage: "
				"Got message from unregistered component %s\n",
			addr.c_str() );

		// TODO: We should probably send an add here, not a del.  The problem at
		// the moment is that server components compiled with out-of-date logger
		// protocol support (see logger_message_forwarder.hpp) will repeatedly
		// generate this warning if we do a naive add here.  We could maybe
		// cache a map of out-of-date components in handleRegisterRequest()
		// below and only send adds to up-to-date components.
		this->sendDel( addr );
		return;
	}

	if (!pLogWriter_->addLogMessage( iter->second, addr, is ))
	{
		ERROR_MSG( "Logger::handleLogMessage: BWLogWriter::addLogMessage() "
			"failed, a log entry has been lost!\n" );
	}
}

/**
 *	This method handles a request to register a component.
 */
void Logger::handleRegisterRequest(
			char * data, int dataLen, const Mercury::Address & addr )
{
	MemoryIStream is( data, dataLen );
	Component component;
	component.read( is );

	if (is.error() || is.remainingLength() > 0)
	{
		ERROR_MSG( "Malformed register request from %s\n", addr.c_str() );
		return;
	}

	if (this->shouldLogFromGroup( addr ) && this->shouldConnect( component ))
	{
		INFO_MSG( "Registering %s at %s (uid:%d, loggerID:\"%s\")\n",
			component.name(), addr.c_str(), component.uid_, 
			component.loggerID_.c_str() );
		components_[ addr ] = component;
	}
	else if (strcmp( "Client", component.name() ) != 0)
	{
		// Clients aren't listening for incoming watcher requests over the
		// nework so don't keep trying to send it to them.

		WARNING_MSG( "Not registering %s at %s\n", component.name(),
			addr.c_str() );
		this->sendDel( addr );
	}
}


/**
 *	This method returns whether or not we should accept the input component.
 */
bool Logger::shouldConnect( const Component & component ) const
{
	// make sure client is sending out packets that we know
	// what to do with.
	if (component.version_ < OLDEST_SUPPORTED_MESSAGE_LOGGER_VERSION)
	{
		WARNING_MSG( "Not registering %s (uid:%d) "
				"(got version %d < oldest supported version = %d)\n",
			component.componentName_.c_str(), component.uid_,
			component.version_, OLDEST_SUPPORTED_MESSAGE_LOGGER_VERSION );
		return false;
	}

	if (component.version_ > MESSAGE_LOGGER_VERSION)
	{
		WARNING_MSG( "Process using newer message format asking "
			"to be logged.. update your logger! %d > %d\n",
		   component.version_, MESSAGE_LOGGER_VERSION );
		return false;
	}

	if (!logAllUsers_ && (logUser_ != component.uid_))
	{
		// Not our UID.
		// shouldLog = false;
		return false;
	}

	if ((!loggerID_.empty()) && (loggerID_ != component.loggerID_))
	{
		// Not correct logger id.
		return false;
	}

	if (!logNames_.empty() &&
			std::find( logNames_.begin(), logNames_.end(),
							component.componentName_ ) == logNames_.end() )
	{
		// Not in valid names.
		return false;
	}

	if (std::find( doNotLogNames_.begin(), doNotLogNames_.end(),
							component.componentName_ ) != doNotLogNames_.end() )
	{
		// Is an invalid name.
		return false;
	}

	return true;
}


bool Logger::shouldLogFromGroup( const Mercury::Address &addr )
{
	bool shouldAccept = true;

	if (!groupNames_.empty())
	{
		uint64 currTime = timestamp() / stampsPerSecond();

		// Attempt to locate an existing set of group information for
		// the potential address.
		MachineGroups *currGroups = NULL;
		currGroups = machineGroups_[ addr.ip ];

		bool hasExpired = ((currGroups != NULL) &&
				((currTime - currGroups->lastPollTime_) >
				::SECONDS_TILL_GROUP_REQUERY));

		// It may be necessary to update the [Groups] information for
		// the machine that about to be added.
		if ((currGroups == NULL) || hasExpired)
		{
			// Query the machine for any Groups it has
			TagsMessage tm;
			tm.tags_.push_back( "Groups" );

			TagsHandler handler( *this );
			if (!this->createEndpointAndQueryMsg( tm, addr.ip, handler ))
			{
				if (hasExpired)
				{
					WARNING_MSG( "Logger::shouldLogFromGroup: Using old "
						"machine groups. Unable to update.\n" );
				}
				else
				{
					ERROR_MSG( "Logger::shouldLogFromGroup: Unable to query "
						"bwmachined on source of potential logs. "
						"Forgetting %s.\n",	addr.c_str() );
					shouldAccept = false;
				}
			}

			currGroups = machineGroups_[ addr.ip ];
			if (currGroups == NULL)
				shouldAccept = false;
		}


		// Now we are certain the group information from bwmachined is up
		// to date, check whether the requesting machine is on our list
		// of machines to listen to.
		if (shouldAccept)
		{
			StringList::iterator ownIter = groupNames_.begin();

			// For the final check we'll invert the should accept and only
			// re-enable it if found.
			shouldAccept = false;

			while ((ownIter != groupNames_.end()) && !shouldAccept)
			{
				StringList::iterator responseIter = currGroups->groups_.begin();

				while ((responseIter != currGroups->groups_.end()) &&
						!shouldAccept)
				{
					if (*responseIter == *ownIter)
						shouldAccept = true;

					responseIter++;
				}

				ownIter++;
			}
		}
	}

	return shouldAccept;
}


// -----------------------------------------------------------------------------
// Section: Misc
// -----------------------------------------------------------------------------

bool Logger::createEndpointAndQueryMsg(
	MachineGuardMessage &mgm, uint32 addr,
	MachineGuardMessage::ReplyHandler &handler )
{
	// Create the socket
	Endpoint ep;
	ep.socket( SOCK_DGRAM );
	u_int32_t ifaddr = INADDR_ANY;
	char iftemp[ IFNAMSIZ ];
	ep.findIndicatedInterface( interfaceName_.c_str(), iftemp );
	ep.getInterfaceAddress( iftemp, ifaddr );
	if (!ep.good() || ep.bind( 0, ifaddr ) != 0)
	{
		ERROR_MSG( "Logger::createEndpointAndQueryMsg: "
					"Problem setting up socket.\n" );
		return false;
	}

	// Query the address with the message
	Mercury::Reason reason = mgm.sendAndRecv( ep, addr, &handler );
	if (reason != Mercury::REASON_SUCCESS)
	{
		ERROR_MSG( "Logger::createEndpointAndQueryMsg: "
			"MGM::sendAndRecv() failed: %s\n",
			Mercury::reasonToString( reason ) );
		return false;
	}

	return true;
}


/**
 *	This method sends an add logger request to the input address.
 */
bool Logger::sendAdd( const Mercury::Address & addr )
{
	if (!this->shouldLogFromGroup( addr ))
	{
		return false;
	}

	this->socket().sendto(
		(char *)addLoggerData_.data(), addLoggerData_.size(),
		addr.port, addr.ip );

	return true;
}


/**
 *	This method sends a del logger request to the input address.
 */
void Logger::sendDel( const Mercury::Address & addr )
{
	this->socket().sendto(
			(char *)delLoggerData_.data(), delLoggerData_.size(),
			addr.port, addr.ip );
}


/**
 *	This method deletes the attachment that we have with a component.
 */
void Logger::delComponent( const Mercury::Address & addr, bool send )
{
	INFO_MSG( "Logger::delComponent: %s\n", addr.c_str() );
	components_.erase( addr );

	if (!pLogWriter_->stopLoggingFromComponent( addr ))
	{
		ERROR_MSG( "Logger::delComponent: "
				"Failed to stop writing component at %s to the logs\n",
			addr.c_str() );
	}

	if (send)
	{
		this->sendDel( addr );
	}
}


/**
 *	This method deletes the attachment that we have with a component.
 */
void Logger::delComponent( Logger::Component * pComponent )
{
	// This is a bit of a brute-force way of doing things (which is probably
	// fine). We could store the address with the component or we could work
	// it out from pComponent since it comes from a map.

	Components::iterator iter = components_.begin();

	while (iter != components_.end())
	{
		if (pComponent == &iter->second)
		{
			this->delComponent( iter->first );
			return;
		}

		++iter;
	}
}


/**
 *	This method refreshes the components that this logger is connected to.
 */
void Logger::commandReattachAll( bool value )
{
	if (value)
	{
		this->initComponents();
	}
}

// -----------------------------------------------------------------------------
// Section: Logger::Component
// -----------------------------------------------------------------------------


/**
 *	This static method returns a watcher for this type.
 */
Watcher & Logger::Component::watcher()
{
	static DirectoryWatcherPtr pWatcher = NULL;

	if (pWatcher == NULL)
	{
		pWatcher = new DirectoryWatcher();
		Component * pNull = NULL;

		pWatcher->addChild( "name",
 			new MemberWatcher< const char *, Logger::Component >( *pNull,
				&Logger::Component::name ) );
		pWatcher->addChild( "uid", new DataWatcher< uint16 >( pNull->uid_ ) );
		pWatcher->addChild( "pid", new DataWatcher< uint32 >( pNull->pid_ ) );
		pWatcher->addChild( "attached",
			new MemberWatcher< bool, Logger::Component >( *pNull,
				MF_ACCESSORS( bool, Logger::Component, commandAttached ) ) );
	}

	return *pWatcher;
}


/**
 *	This method sents whether or not this component is attached.
 */
void Logger::Component::commandAttached( bool value )
{
	if (!value && g_pInstance_)
	{
		g_pInstance_->delComponent( this );
	}
}
